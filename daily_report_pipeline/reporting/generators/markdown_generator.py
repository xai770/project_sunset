"""
Markdown Report Generator
=======================

Generates Markdown reports for collaborative review.
"""

from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List

class MarkdownReportGenerator:
    """Generates detailed Markdown reports"""
    
    def __init__(self, reports_path: Path):
        """Initialize the Markdown report generator
        
        Args:
            reports_path: Directory where reports will be saved
        """
        self.reports_path = reports_path
        self.reports_path.mkdir(exist_ok=True)
    
    def generate_report(self, report_data: List[Dict[str, Any]]) -> Path:
        """Generate a Markdown report from the provided data
        
        Args:
            report_data: List of job report entries
            
        Returns:
            Path to the generated Markdown file
        """
        if not report_data:
            raise ValueError("No data provided for report generation")
            
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        md_path = self.reports_path / f"daily_report_{timestamp}.md"
        
        print(f"Creating Markdown report: {md_path}")
        
        content = self._generate_header(len(report_data))
        content += self._generate_job_sections(report_data)
        content += self._generate_metadata(timestamp)
        
        with open(md_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"Markdown report created: {md_path}")
        return md_path
    
    def _generate_header(self, job_count: int) -> str:
        """Generate the report header section"""
        return f"""# Daily Job Analysis Report - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Report Summary
- **Total Jobs Processed**: {job_count}
- **Analysis Date**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- **Report Format**: Job Matching Format (28 columns)
- **Generated By**: Modular Daily Report Generator

## Jobs Analysis

"""
    
    def _generate_job_sections(self, report_data: List[Dict[str, Any]]) -> str:
        """Generate the job analysis sections"""
        content = ""
        for i, job in enumerate(report_data, 1):
            content += self._format_job_section(i, job)
        return content
    
    def _format_job_section(self, index: int, job: Dict[str, Any]) -> str:
        """Format a single job section"""
        return f"""### Job #{index}: {job['job_id']} - {job['position_title']}

**Core Job Information:**
- **Job ID**: {job['job_id']}
- **Position Title**: {job['position_title']}
- **Concise Description**: {job['concise_description']}
- **Validated Location**: {job['validated_location']}
- **Metadata Location**: {job['metadata_location']}
- **Location Validation**: {job['location_validation_details']}
- **Match Level**: {job['match_level']}

**ðŸ“‹ Full Content (Raw Job Description):**
```
{job['full_content']}
```

**ðŸŽ¯ 5D Requirements Extraction:**
- **Technical Requirements**: {job.get('technical_requirements', 'Not extracted')}
- **Business Requirements**: {job.get('business_requirements', 'Not extracted')}
- **Soft Skills**: {job.get('soft_skills', 'Not extracted')}
- **Experience Requirements**: {job.get('experience_requirements', 'Not extracted')}
- **Education Requirements**: {job.get('education_requirements', 'Not extracted')}

**ï¿½ Job Matching Scores:**
- **Technical Match**: {job.get('technical_requirements_match', 'Pending job matching engine')}
- **Business Match**: {job.get('business_requirements_match', 'Pending job matching engine')}
- **Soft Skills Match**: {job.get('soft_skills_match', 'Pending job matching engine')}
- **Experience Match**: {job.get('experience_requirements_match', 'Pending job matching engine')}
- **Education Match**: {job.get('education_requirements_match', 'Pending job matching engine')}

**ðŸ“ Application Decision:**
- **No-go Rationale**: {job['no_go_rationale']}
- **Application Narrative**: {job['application_narrative']}

**ðŸ“‹ Processing Logs:**
- **Generate Cover Letters Log**: {job['generate_cover_letters_log']}
- **Reviewer Feedback**: {job['reviewer_feedback']}
- **Mailman Log**: {job['mailman_log']}
- **Process Feedback Log**: {job['process_feedback_log']}
- **Reviewer Support Log**: {job['reviewer_support_log']}
- **Workflow Status**: {job['workflow_status']}

**ðŸŒ¸ Sandy's Consciousness Analysis:**
- **Story Interpretation**: {job['human_story_interpretation']}
- **Encouragement Synthesis**: {job['encouragement_synthesis']}

---

"""
    
    def _generate_metadata(self, timestamp: str) -> str:
        """Generate the report metadata section"""
        return f"""## Report Metadata

**Golden Rules Compliance:**
- Job matching format (28 columns) structure maintained
- Full job description included (not truncated)  
- Concise job description from LLM extraction included
- Location validation details with conflict analysis included
- 5D requirements extraction populated
- Job matching score placeholders included
- Consciousness analysis fields with quality review status
- Reports saved in `/reports` directory

**Modular Architecture:**
- Content Extraction Specialist v4.0 (with 5D requirements)
- Location Validation Specialist v3.0 (Enhanced LLM)
- Text Summarization Specialist
- Clean separation of concerns
- Testable components

**Report Generation Details:**
- **Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- **Excel Report**: `daily_report_{timestamp}.xlsx`
- **Markdown Report**: `daily_report_{timestamp}.md`
- **Reports Directory**: `/home/xai/Documents/sandy/reports/`

---
*Report generated using Sandy's modular architecture following Golden Rules for precision-first collaborative intelligence workflow.*
"""
